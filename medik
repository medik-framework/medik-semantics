#!/usr/bin/env python3

from pathlib import Path
from argparse import ArgumentParser

import asyncio, contextlib, logging, os, sys, json, tempfile, json


base_dir     = Path(__file__).parents[0]
kompiled_dir = base_dir     / '.build' / 'medik-kompiled'
krelease_dir = base_dir     / 'ext'    / 'k' / 'k-distribution' / 'target' / 'release' / 'k'
kbin_dir     = krelease_dir / 'bin'


def set_env():
    path_entires = [ kbin_dir ]
    os.environ['PATH'] = str(kbin_dir.resolve()) \
                            + os.pathsep + os.environ['PATH']

async def read_stdout(k_process, recv_cb=lambda msg: print(json.dumps(msg))):
    while True:
        logging.info('waiting for k:')
        out = await k_process.stdout.readline()
        if not out:
            break
        out_json = json.loads(out)
        match out_json.get('action'):
            case 'print':
                print(*out_json['args'], end='', flush=True)
            case _:
                recv_cb(out_json)

async def read_stderr(k_process):
    while True:
        err = await k_process.stderr.read()
        if not err:
            break
        else:
            sys.stderr.write(err.decode('utf-8'))
            sys.stderr.flush()

async def write_stdin(k_process, in_file=None):
    if in_file != None:
        with open(in_file) as in_file_obj:
            in_data = in_file_obj.read()

        logging.info('sending to k: {}'.format(in_data))
        k_process.stdin.write(in_data.encode('utf-8'))
        await k_process.stdin.drain()
        logging.info('sending to k complete')

async def krun(pgm_file, in_file=None):
    set_env()

    k_command = ( 'krun' , ['-d' , str(kompiled_dir.resolve())
                           , '--output' , 'none'
                           , pgm_file ])

    in_pipe = asyncio.subprocess.DEVNULL
    if in_file != None:
        in_pipe = asyncio.subprocess.PIPE

    k_process = await asyncio.create_subprocess_exec( k_command[0]
                                                    , *k_command[1]
                                                    , stdin=in_pipe
                                                    , stdout=asyncio.subprocess.PIPE
                                                    , stderr=asyncio.subprocess.PIPE)

    await write_stdin(k_process, in_file)
    await asyncio.gather(read_stdout(k_process), read_stderr(k_process), return_exceptions=True)
    return k_process.returncode

def main():
    parser = ArgumentParser(description='MediK Interpreter')

    parser.add_argument('-in', '--in-file'
                       , help='File with input messages'
                       , nargs=1
                       , dest='in_file')
    parser.add_argument('pgm_file'
                       , metavar='PGM_FILE'
                       , help='MediK file to run')
    parser.add_argument('-v', '--verbose'
                       , help='print verbose logs'
                       , action='store_const'
                       , dest='loglevel'
                       , const=logging.INFO
                       )

    args = parser.parse_args()
    logging.basicConfig(level=args.loglevel)
    retval = 0
    if args.in_file != None:
        retval = asyncio.run(krun(args.pgm_file, args.in_file[0]))
    else:
        retval = asyncio.run(krun(args.pgm_file))
    return sys.exit(retval)

if __name__ == "__main__":
    main()
