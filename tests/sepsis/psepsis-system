#!/usr/bin/env python3

import json, asyncio, logging, os, sys, functools

from pathlib import Path
from argparse import ArgumentParser

base_dir     = Path(__file__).parents[0]
kompiled_dir = base_dir                  / '..' / '..' / '.build' / 'medik-kompiled'
krelease_dir = base_dir                  / '..' / '..' / 'ext'    / 'k' / 'k-distribution' / 'target' / 'release' / 'k'
kbin_dir     = krelease_dir              / '..' / '..' / 'bin'
psepsis      = base_dir                  / 'psepsis.medik'

def set_env():
    path_entires = [ kbin_dir ]
    os.environ['PATH'] = str(kbin_dir.resolve()) \
                            + os.pathsep + os.environ['PATH']

from_k_queue = asyncio.Queue()
tasks        = set()

async def parse_json_stream(json_stream):
    open_brace_count  = 0
    close_brace_count = 0
    last_scan_index   = 0
    json_byte_str       = b''
    try:
        while True:
            json_byte_str       += await json_stream.readuntil(b'}')
            open_brace_count  += json_byte_str.count(b'{', last_scan_index)
            close_brace_count += json_byte_str.count(b'}', last_scan_index)
            if len(json_byte_str) == 0:
                return None
            if open_brace_count == close_brace_count:
                obj = json.loads(json_byte_str)
                json_byte_str       = b''
                last_scan_index   = 0
                open_proce_count  = 0
                close_brace_count = 0
                return obj
            last_scan_index = len(json_byte_str)
    except asyncio.IncompleteReadError:
        return None

async def _sleep(k_process, duration, tid):
    logging.info('sleeping for duration {} for tid {}'.format(duration, tid))
    await asyncio.sleep(duration)
    k_process.stdin.write(json.dumps({ 'tid'    : tid
                                     , 'action' : 'sleepResponse' }, sort_keys=True).encode('utf-8'))
    await k_process.stdin.drain()
    logging.info('sleep complete message sent for tid {}'.format(tid))

async def read_out_stream(k_process):
    while True:
        logging.info('waiting for k on stdout')
        out_json = await parse_json_stream(k_process.stdout)
        if out_json == None:
            break;
        try:
            await from_k_queue.put(out_json)
        except (ValueError, AttributeError) as e:
            sys.err.write(str(e))
            return None


def kill_tasks(context):
    logging.info('finished task {}'.format(context))
    for task in asyncio.all_tasks():
        task.cancel()

async def interact(k_process, in_file=None):
    in_messages = None
    sent_index = 0
    use_stdin = False

    if in_file != None:
        with open(in_file) as in_file_handler:
            in_messages = json.loads(in_file_handler.read())
    else:
        use_stdin = True

    read_out_task = asyncio.create_task(read_out_stream(k_process), name='k_process_stoud_read_task')
    tasks.add(read_out_task)
    read_out_task.add_done_callback(kill_tasks)
    read_out_task.add_done_callback(tasks.discard)

    while use_stdin or sent_index < len(in_messages):
        if not use_stdin:
            k_process.stdin.write(json.dumps(in_messages[sent_index]).encode('utf-8'))
            await k_process.stdin.drain()
            sent_index = sent_index + 1
        else:
            from_stdin = json.loads(input("to-k?>"))
            k_process.stdin.write(json.dumps(from_stdin).encode('utf-8'))
            await k_process.stdin.drain()

        if k_process.returncode != None:
            do_exit()
        from_k = await from_k_queue.get()
        match from_k.get('action'):
            case 'print':
                print(*from_k['args'], end='', flush=True)
            case 'sleep':
                sleep_task = asyncio.create_task(_sleep( k_process
                                                , out_json['duration']
                                                , out_json['tid']))
                tasks.add(sleep_task)
                sleep_task.add_done_callback(tasks.discard)
            case 'exit':
                do_exit()
                break
            case _:
                print(json.dumps(from_k, indent=2))


async def krun(in_file=None):
    set_env()

    k_command = ( 'krun' , ['-d' , str(kompiled_dir.resolve())
                           , '--output' , 'none'
                           , str(psepsis.resolve()) ])

    k_process = await asyncio.create_subprocess_exec( k_command[0]
                                                    , *k_command[1]
                                                    , stdin=asyncio.subprocess.PIPE
                                                    , stdout=asyncio.subprocess.PIPE
                                                    , stderr=asyncio.subprocess.PIPE)

    try:
        await interact(k_process, in_file)
    except asyncio.exceptions.CancelledError:
        logging.info('Exit')


async def main():
    parser = ArgumentParser(description='PSepsis Guidance System')

    parser.add_argument('-in', '--in-file'
                       , help='File with input messages'
                       , nargs=1
                       , dest='in_file')
    parser.add_argument('-v', '--verbose'
                       , help='print verbose logs'
                       , action='store_const'
                       , dest='loglevel'
                       , const=logging.INFO
                       )

    args = parser.parse_args()
    logging.basicConfig(level=args.loglevel, format='%(message)s')
    retval = 0
    if args.in_file != None:
        retval = await krun(args.in_file[0])
    else:
        retval = await krun()
    return retval

if __name__ == "__main__":
    retval = asyncio.run(main())
    sys.exit(retval)

